RequestMappingTemplate: |
  ## Ideally, we want a map of userId and reactions, so user cannot vote twice.
  ## But you cannot "SET reactions.UserId=somereaction" if reactions map doesn't yet exist.
  ## So we record every reaction -- even duplicate reactions -- and rely on clients to
  ## strip duplicates.
  #if($ctx.identity && $ctx.identity.username)
    #set($userId = $ctx.identity.username)
  #else
      #set($userId = "CORNCHAT_ADMIN")
  #end
  {
      "version" : "2017-02-28",
      "operation" : "UpdateItem",
      "update": {
      	"expression": "SET reactions = list_append(if_not_exists(reactions, :empty_list), :new_reactions), room = :room",
          "expressionValues": {
            ":new_reactions": {
              "L": [
                {
                  "M": {
                    "emoji": $util.dynamodb.toDynamoDBJson($ctx.args.emoji),
                    "userId": $util.dynamodb.toDynamoDBJson($userId)
                  }
                }
              ]
            },
            ":empty_list": {
              "L": [
              ]
            },
            ":room": $util.dynamodb.toDynamoDBJson($ctx.args.room)
          }
      },
      "key" : {
          "mid": $util.dynamodb.toDynamoDBJson($ctx.args.mid)
      }
  }
ResponseMappingTemplate: |
  $util.toJson($ctx.result)
